<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies"><div><img src="https://i.imgur.com/Emo7umQ.jpg" alt="JSON Web Tokens vs. Session Cookies: In Practice"></div></a>

<h1>JSON Web Tokens vs. Session Cookies: In Practice</h1>

<p><kbd>jwt</kbd> <kbd>sessions</kbd> <kbd>authentication</kbd></p>

<blockquote><p>Quite a few challenges have been found with using server-side sessions in modern-day applications. In this post, we&#x2019;ll identify those challenges and explain how JWT and sessions work in practice.</p>
</blockquote>

<div><p><strong>TL;DR</strong> Many modern web applications use JSON Web Tokens (JWT), rather than the traditional session-based authentication. Quite a few challenges have been found with using server-side sessions in modern-day applications. In this post, we&#x2019;ll identify those challenges and explain how JWT and sessions work in practice.</p></div>

<blockquote><p>There was a bit of controversy recently about the use cases where JWT really shines, and the ones where it doesn&#x2019;t do such a great job. Namely, are JSON web tokens good enough for sessions <em>&#x2013; or should we keep using cookies instead?</em></p> <p><a href="https://ponyfoo.com/contributors/prosper-otemuyiwa" aria-label="Check out Prosper&apos;s profile!">Prosper</a> from <strong>Auth0</strong> approached us about writing a guest post on Pony Foo, and he&#x2019;ll be addressing exactly those questions. &#x1F36A;</p><p align="right"><sub><em>&#x2014; Editor&#x2019;s note.</em></sub></p></blockquote>

<div><h2 id="what-are-json-web-tokens">What Are JSON Web Tokens?</h2> <p>JSON Web Token (JWT) is an open standard (<a href="https://tools.ietf.org/html/rfc7519" target="_blank">RFC 7519</a>) that defines a compact and self-contained way to securely transmit information between parties as a JSON Object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with HMAC algorithm) or a public/private key pair using RSA.</p> <h2 id="jwt-anatomy">JWT Anatomy</h2> <p>JWTs basically consist of three parts separated by a <code class="md-code md-code-inline">.</code> . This is the header, payload and signature. Check out this excellent <a href="https://auth0.com/learn/json-web-tokens/" target="_blank">article</a> for a comprehensive explanation of the JWT Structure.</p></div>

<div><h3 id="how-json-web-tokens-work">How JSON Web Tokens Work</h3> <p>In authentication, when the user successfully logs in using his credentials, a JSON Web Token will be returned and must be saved locally (typically in local storage, but cookies can be also used), instead of the traditional approach of creating a session in the server and returning a cookie.</p> <p>Whenever the user wants to access a protected route, it should send the JWT, typically in the Authorization header using the Bearer schema. Therefore, the content of the header should look like the following:</p> <pre class="md-code-block"><code class="md-code md-lang-xml">Authorization: <mark class="md-mark md-code-mark">Bearer <span class="md-code-tag">&lt;<span class="md-code-title">token</span>&gt;</span></mark>
</code></pre> <p>This is a stateless authentication mechanism as the user state is never saved in the server memory. The server&#x2019;s protected routes will check for a valid JWT in the Authorization header, and if it is there, the user will be allowed. As JWTs are self-contained, all the necessary information is there, reducing the need to go back and forth to the database.</p> <p>This allows the user to fully rely on data APIs that are stateless and even make requests to downstream services. It doesn&#x2019;t matter which domains are serving your APIs, as Cross-Origin Resource Sharing (CORS) won&#x2019;t be an issue since it doesn&#x2019;t use cookies.</p> <p><strong>Authentication flow</strong></p> <figure><img alt="image description" class="" src="https://i.imgur.com/0fZ13rD.png"></figure> <h2 id="why-should-you-use-jwts">Why Should You Use JWTs</h2> <p>There are several reasons that you should use JSON Web Tokens.</p> <ul> <li>They are easy to scale horizontally</li> <li>They are easier to maintain and debug</li> <li>They have the ability to create truly RESTful Services</li> <li>They have built-in expiration functionality.</li> <li>JSON Web Tokens are self-contained.</li> </ul> <p>The points highlighted above will be explained in detail in the next section.</p> <h2 id="jwts-vs-sessions">JWTs vs. Sessions</h2> <p>Before the emergence of JSON Web Tokens, we had the predominant server-based authentication. As we all know, HTTP Protocol is stateless, this means that if we authenticate a user with a username and password, then on the next request, our application won&#x2019;t know who we are. We would have to authenticate again. So there was a need to ensure that after a user has logged in, the user&#x2019;s authentication status can still be verified on every subsequent HTTP request.</p> <figure><img alt="image description" class="" src="https://i.imgur.com/cGa7eQn.png"></figure> <p>A user&#x2019;s credentials are sent as a POST request to the server. The server authenticates the user. If the credentials are valid, the server responds with a cookie, which is set on the user&#x2019;s browser and includes a <strong>SESSION ID</strong> to identify the user. The user sessions are stored in memory either via files or in the database on the server. In this section, I&#x2019;ll elaborate on several points that will be used as a basis for comparing JWTs with sessions in practice.</p> <p><strong>1. Scalability:</strong> As your application grows and your user base increases, you&#x2019;ll have to start scaling either horizontally or vertically. Session data is stored in memory on the server either via files or in a database. In a horizontal scaling scenario, where you have to start replicating servers, you have to come up with a separate central session storage system that all of your application servers have access to. Otherwise, you won&#x2019;t be able to scale your application because of the session-store drawback. Another way to solve this challenge is to use the concept of <a href="http://stackoverflow.com/questions/10494431/sticky-and-non-sticky-sessions" target="_blank">sticky sessions</a>. You can also store your sessions on disk to make your application easy to scale in a cloud environment. These types of workarounds don&#x2019;t really play well with modern large applications. Setting up and maintaining this type of distributed system involves in-depth technical knowledge and subsequently incurs higher financial costs. Using JWTs, in this case, is seamless; there is no need to store user information in the session since token-based authentication is stateless. Our application can scale easily because we can use tokens to access resources from different servers without worrying if the user was actually logged in on a particular server. You also save costs because you don&#x2019;t need a dedicated server to store your sessions. Why? Because there are no sessions!</p> <p><strong>Note:</strong> If you are building small applications that absolutely don&#x2019;t need to scale up to running on multiple servers and have no need for RESTful APIs, sessions will definitely work fine for you. And if you can use a dedicated server to run a tool like Redis for your session storage, then sessions might also work perfectly for you!</p> <p><strong>2. Security:</strong> Signing JWTs already aim to prevent tampering on the client side, but they can also be encrypted to ensure that the claim that the token carries is very secure. Now, JWTs are mostly either directly stored in web storage ( local/session storage) or in cookies. And JavaScript has access to web storage on the same domain. This simply means that your JWTs might be vulnerable to XSS (Cross-site Scripting). Malicious JavaScript can be embedded on a page to read and compromise the contents of your Web Storage. In fact, a lot of people advocate that very sensitive data shouldn&#x2019;t be stored in Web Storage because of XSS attacks. A very typical example is ensuring that your JWTs are not encoded with very sensitive/trusted data, such as a user&#x2019;s Social Security Number.</p> <p>Initially, I mentioned that JWTs can be stored in cookies. In fact, JWTs are stored as cookies on many occasions, and cookies are vulnerable/susceptible to <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank">CSRF (Cross-site Request Forgery)</a> attacks. One of the many ways to prevent CSRF attacks is to ensure that your cookie is accessible by only your domain. As a developer, ensure that necessary CSRF protections are put in place to avoid these attacks, regardless of the use of JWTs.</p> <p>Now, JWTs and session ids can also be exposed to unmitigated replay attacks. It is totally up to the developers to establish what replay-mitigation techniques are appropriate for their systems. One way of solving this problem is ensuring that JWTs rely on short expiration times. Although, this technique doesn&#x2019;t totally solve the problem. However, other alternatives for solving this challenge are issuing JWTs to specific IP addresses and using <a href="http://www.networkworld.com/article/2884026/security0/browser-fingerprints-and-why-they-are-so-hard-to-erase.html" target="_blank">browser fingerprinting</a>.</p> <p><strong>Note</strong>: Use HTTPS/SSL to ensure that your cookies and JWTs are encrypted by default during client and server transmission. This helps avoid man-in-the-middle attacks!</p> <p><strong>3. RESTful API Services:</strong> A common pattern for modern applications is to retrieve and consume JSON data from a RESTful API. Most applications these days have <a href="http://www.restapitutorial.com/" target="_blank">RESTful APIs</a> for other developers or applications to consume. Serving data from an API has several distinct advantages, one of them which is the ability for data to be used in more than just one application. The traditional approach of using sessions and cookies for the user&#x2019;s identity doesn&#x2019;t work well in this case because they introduce the <strong>state</strong> to the application.</p> <p>One of the tenets of a RESTful API is that it should be stateless, which means that when a request is made, a response within certain parameters can always be anticipated without side effects. A user&#x2019;s authentication state introduces such a side effect, which breaks this principle. Keeping the API stateless and therefore without side effects means that maintainability and debugging are made much easier.</p> <p>Another challenge here is that it is quite common for an API to be served from one server and for the actual application to consume it from another. To make this happen, we need to enable <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">Cross-Origin Resource Sharing (CORS)</a>. Since cookies can only be used for the domain from which they originated, they aren&#x2019;t much help for APIs on different domains than the application. Using JWTs for authentication in this case ensures that the RESTful API is stateless, and you also don&#x2019;t have to worry about where the API or the application is being served from!</p> <p><strong>4. Performance:</strong> A critical analysis of this is very necessary. When making requests from the client to the server, if a lot of data is encoded within the JWT, it creates a significant amount of overhead with every HTTP request. However, with sessions, there is only a tiny amount of overhead because <strong>SESSION IDs</strong> are actually very small. Look at this example below:</p> <p>A JWT has 5 claims like so:</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">sub</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;1234567890&quot;</span></span>,
  &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;Prosper Otemuyiwa&quot;</span></span>,
  &quot;<span class="md-code-attribute">admin</span>&quot;: <span class="md-code-value"><span class="md-code-literal">true</span></span>,
  &quot;<span class="md-code-attribute">role</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;manager&quot;</span></span>,
  &quot;<span class="md-code-attribute">company</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;Auth0&quot;</span>
</span>}
</code></pre> <p>When encoded, the size of the JWT will be several times the size of a <strong>SESSION ID (identifier)</strong>, thus making this JWT add more overhead than a <strong>SESSION ID</strong> with every HTTP request. With sessions, there is also a server side lookup to find and deserialize the session on each request.</p> <p>JWTs trade size for latency by keeping the data on the client side. The data model of your application is a significant factor here because latency is saved by preventing incessant calls and queries to the database on the server. The idea here is to be careful not to store too many claims in a JWT to avoid huge, over-bloated requests.</p> <p>Worthy of mention is the fact that tokens may require access to the database on the backend. This is particularly the case for refresh tokens. They may require access to a database on the authorization server for blacklisting. Get more info about <a href="https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/" target="_blank">refresh tokens and when to use them</a>. Also, check out this <a href="https://auth0.com/blog/blacklist-json-web-token-api-keys" target="_blank">article</a> for more information on blacklisting.</p> <p><strong>Note:</strong> Developers need to strike a balance to make the usage of JWTs really worth it!</p> <figure><img alt="image description" class="" src="https://i.imgur.com/VTtdMwC.png"></figure> <p><sub><em>Source: Quora</em></sub></p> <p><strong>5. Downstream Services:</strong> Another common pattern seen with modern web applications is that they often rely on downstream services. For example, a call to the main application server might make a request to a downstream server before the original request is resolved. The issue here is that cookies don&#x2019;t flow easily to the downstream servers and can&#x2019;t tell those servers about the user&#x2019;s authentication state. Since each server has its own scheme for cookies, there is a lot of resistance to flow, and connecting to them is difficult. JSON web tokens again makes these a breeze!</p> <h2 id="authentication-with-auth0-using-jwts">Authentication with Auth0 using JWTs</h2> <p>In <strong>Auth0</strong>, we issue JWTs as a result of the authentication process. When the user logs in using Auth0, a JWT is created, signed, and sent to the user. <strong>Auth0</strong> supports signing JWT with both HMAC and RSA algorithms. The user has the flexibility to actually choose any of these two algorithms from the dashboard. This token will be then used to authenticate and authorize with APIs, which will grant access to their protected routes and resources.</p> <p>We also use JWTs to perform authentication and authorization in <a href="https://auth0.com/docs/api/management/v2" target="_blank">Auth0&#x2019;s API v2</a>, replacing the traditional usage of regular opaque API keys. Regarding authorization, JSON Web Tokens allow granular security, which is the ability to specify a particular set of permissions in the token, thus improving debuggability.</p> <h2 id="conclusion">Conclusion</h2> <p>JSON Web Tokens (JWTs) are lightweight and can easily be used across platforms and languages. They are a clever way to authenticate &amp; authorize without sessions. There are several <a href="https://jwt.io/#libraries-io" target="_blank">JWT libraries</a> available for signing and verifying the tokens. There are also many reasons to use tokens, and Auth0 can help implement token authentication in an easy and secure way.</p> <p>Personally, I don&#x2019;t think there is a one-size-fits-all approach. It will always depend on your application architecture and use case.</p> <p>Would you still prefer using sessions in practice over JSON Web Tokens? Let us know your thoughts in the comment section!</p></div>

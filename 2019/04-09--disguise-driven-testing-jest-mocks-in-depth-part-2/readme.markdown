<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/disguise-driven-testing-jest-mocks-in-depth-part-2">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/disguise-driven-testing-jest-mocks-in-depth-part-2"><div><img src="https://cdn-images-1.medium.com/max/1600/1*1uhAUO_qrgI-dZiquKEZKw.jpeg" alt="Disguise Driven Testing: Jest Mocks In Depth &#x2014; Part 2"></div></a>

<h1>Disguise Driven Testing: Jest Mocks In Depth &#x2014; Part 2</h1>

<p><kbd>jest</kbd> <kbd>testing</kbd></p>

<blockquote><p>Mocks are a great way of preventing AJAX calls in tests, but they can also help you isolate side effects and impurities that can create complicated tests.</p> <p>As you <a href="https://ponyfoo.com/articles/disguise-driven-testing-jest-mocks-in-depth" aria-label="Disguise-Driven Testing: Jest Mocks in Depth &#x2014; Part 1 on Pony Foo">learned &#x2026;</a></p></blockquote>

<div></div>

<blockquote></blockquote>

<div><p>Mocks are a great way of preventing AJAX calls in tests, but they can also help you isolate side effects and impurities that can create complicated tests.</p> <p>As you <a href="https://ponyfoo.com/articles/disguise-driven-testing-jest-mocks-in-depth" aria-label="Disguise-Driven Testing: Jest Mocks in Depth &#x2014; Part 1 on Pony Foo">learned in Part 1</a>, mocks are a great way to handle external data or any data that is likely to change. Mocking external data will likely be your most common use case and for a good reason. You want your tests to stick as closely to your code as possible this includes all dependencies. Still, there are times when a dependency creates a testing specific problem. In other words, the code works as you would want it to in production, but in a testing environment can make consistent, predictable tests hard or nearly impossible.</p> <p>Some of your third party code may have side effects or some form of impurity that will complicate your testing. Maybe the code has certain expectations of the DOM. Maybe it will change slightly depending on the order of operations. In all cases, the code is out of your control, but you need it to be predictable.</p></div>

<div><h3 id="creating-predictable-outcomes-with-mocks">Creating Predictable Outcomes with Mocks</h3> <p>Suppose you have an application that manages employees or users. You need to make a simple function that will create a new employee, but you want to make sure that the employee always contains certain fields and will have a unique id.</p> <p>Your code will look something like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import uniqueId from <span class="md-code-string">&apos;lodash/uniqueId&apos;</span>

export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createEmployee</span><span class="md-code-params">(details)</span> </span>{
  <span class="md-code-keyword">return</span> {
    name: <span class="md-code-string">&apos;&apos;</span>,
    position: <span class="md-code-string">&apos;&apos;</span>,
    ...details,
    key: uniqueId()
  }
}
</code></pre> <p>In this case, you are using the Lodash method <code class="md-code md-code-inline">uniqueId</code> to, <em>well</em>, create a unique ID. Specifically you are creating a key that you can use if you do any manipulations on an array of employees. The key, though, is a minor thing.</p> <p>For the most part, your tests should focus on other aspects of your code such as ensuring default fields while allowing those fields to override. Here are two simple tests.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { createEmployee, } from <span class="md-code-string">&apos;./utils&apos;</span>

describe(<span class="md-code-string">&apos;createEmployee&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should create a blank employee&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee()
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;1&apos;</span>
    }

    expect(blank).toEqual(expected)
  })

  it(<span class="md-code-string">&apos;should create use existing details when creating employee&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee({ name: <span class="md-code-string">&apos;Bill&apos;</span> })
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;Bill&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;2&apos;</span>
    }

    expect(blank).toEqual(expected)
  })
})
</code></pre> <p>Notice anything strange in the expectations? In the first case, the key is <code class="md-code md-code-inline">&apos;1&apos;</code> in the next test it&#x2019;s <code class="md-code md-code-inline">&apos;2&apos;</code>. Here&#x2019;s where the problems start to sneak in. Every time you add a test, you need to iterate the <code class="md-code md-code-inline">key</code>. The <code class="md-code md-code-inline">uniqueId</code> function is doing exactly what you would want in production, but in the testing case, it&#x2019;s creating a situation where your tests <em>always</em> have to run in the same order.</p> <p>Suppose you needed to change the function slightly to handle cases where you get an object with a field of <code class="md-code md-code-inline">firstName</code> and you want to use as the <code class="md-code md-code-inline">name</code> field:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import uniqueId from <span class="md-code-string">&apos;lodash/uniqueId&apos;</span>

export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createEmployee</span><span class="md-code-params">(details = {})</span> </span>{
  <span class="md-code-keyword">const</span> { firstName: name, ...rest } = details

  <span class="md-code-keyword">return</span> {
    name: name || <span class="md-code-string">&apos;&apos;</span>,
    position: <span class="md-code-string">&apos;&apos;</span>,
    ...rest,
    key: uniqueId()
  }
}
</code></pre> <p>Your tests now look like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { createEmployee, } from <span class="md-code-string">&apos;./utils.next&apos;</span>

describe(<span class="md-code-string">&apos;createEmployee&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should create a blank employee&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee()
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;1&apos;</span>
    }

    expect(blank).toEqual(expected)
  })

  it(<span class="md-code-string">&apos;should create use existing details when creating employee&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee({ name: <span class="md-code-string">&apos;Bill&apos;</span> })
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;Bill&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;2&apos;</span>
    }

    expect(blank).toEqual(expected)
  })

  it(<span class="md-code-string">&apos;should convert firstName to name&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee({ firstName: <span class="md-code-string">&apos;Bill&apos;</span> })
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;Bill&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;3&apos;</span>
    }

    expect(blank).toEqual(expected)
  })
})
</code></pre> <p>What happens if you change the order? Suppose you wanted to only run the third test:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { createEmployee, } from <span class="md-code-string">&apos;./utils.next&apos;</span>

describe(<span class="md-code-string">&apos;createEmployee&apos;</span>, () =&gt; {
  <span class="md-code-comment">// &#x2026; other tests &#x2026;</span>

  it.only(<span class="md-code-string">&apos;should convert firstName to name&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee({ firstName: <span class="md-code-string">&apos;Bill&apos;</span> })
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;Bill&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;3&apos;</span>
    }

    expect(blank).toEqual(expected)
  })
})
</code></pre> <p>You&#x2019;d get an error. But it&#x2019;s not because your code is wrong. The order has just changed.</p> <pre class="md-code-block"><code class="md-code md-lang-diff">  expect(<mark class="md-mark md-code-mark">received</mark>).toEqual(<mark class="md-mark md-code-mark">expected</mark>)

  Expected value to equal:
<span class="md-code-deletion">-   {&quot;key&quot;: &quot;3&quot;, &quot;name&quot;: &quot;Bill&quot;, &quot;position&quot;: &quot;&quot;}</span>
  Received:
<span class="md-code-addition">+   {&quot;key&quot;: &quot;1&quot;, &quot;name&quot;: &quot;Bill&quot;, &quot;position&quot;: &quot;&quot;}</span>

  Difference:

<span class="md-code-deletion">-   Expected:</span>
<span class="md-code-addition">+   Received:</span>

    Object {
<span class="md-code-deletion">-     &quot;key&quot;: &quot;3&quot;,</span>
<span class="md-code-addition">+     &quot;key&quot;: &quot;1&quot;,</span>
      &quot;name&quot;: &quot;Bill&quot;,
      &quot;position&quot;: &quot;&quot;,
    }

  &#x2026;
</code></pre> <p>So how can you fix it? In this case, you have a couple of options.</p> <p>The easiest option is to override it inside the test itself. By using <code class="md-code md-code-inline">mockImplementation</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { createEmployee, } from <span class="md-code-string">&apos;./utils.next&apos;</span>
import uniqueId from <span class="md-code-string">&apos;lodash/uniqueId&apos;</span>

uniqueId.mockImplementation(() =&gt; <span class="md-code-string">&apos;1&apos;</span>)

describe(<span class="md-code-string">&apos;createEmployee&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should create a blank employee&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee()
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;1&apos;</span>
    }

    expect(blank).toEqual(expected)
  })

  it(<span class="md-code-string">&apos;should create use existing details when creating employee&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee({ name: <span class="md-code-string">&apos;Bill&apos;</span> })
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;Bill&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;1&apos;</span>
    }

    expect(blank).toEqual(expected)
  })

  it(<span class="md-code-string">&apos;should convert firstName to name&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee({ firstName: <span class="md-code-string">&apos;Bill&apos;</span> })
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;Bill&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;1&apos;</span>
    }

    expect(blank).toEqual(expected)
  })
})
</code></pre> <p>Notice what&#x2019;s happening. First, you import the code with <code class="md-code md-code-inline">import uniqueId from &apos;lodash/uniqueId&apos;</code>, then you add a <code class="md-code md-code-inline">mockImplementation</code> to the function you want to control. Jest will now use the <code class="md-code md-code-inline">mockImplementation</code> rather than the actual code anytime you call the function.</p> <p>In other words, you now have a function that returns the result you want everytime. After that, you can write each test expect the exact same key. After all, you don&#x2019;t really care what the key is, you just want it to be there.</p> <p>Another option is to just define the return value using <code class="md-code md-code-inline">mockReturnValue</code>. The steps are the same, but instead of returning a function, you just declare the desired return value.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { createEmployee, } from <span class="md-code-string">&apos;./utils.next&apos;</span>
import uniqueId from <span class="md-code-string">&apos;lodash/uniqueId&apos;</span>

uniqueId.mockReturnValue(<span class="md-code-string">&apos;2&apos;</span>)

<span class="md-code-comment">// Tests are the same</span>
</code></pre> <p>Those are both perfectly good solutions. You may reach for <code class="md-code md-code-inline">mockImplementation</code> in situations where you need to check parameters before you decide what to return.</p> <p>The problem with both solutions is that you have a little extra boilerplate for every single test suite that uses the <code class="md-code md-code-inline">uniqueId</code>. To solve that, you can use a similar technique to mocking out the API.</p> <p>Create a new directory called <code class="md-code md-code-inline">__mocks__</code> at the same level as your <code class="md-code md-code-inline">node_modules</code> directory. This will almost certainly be the root of your project. Inside <code class="md-code md-code-inline">__mocks__</code> create a file structure that emulates your import. In this case, you need a Lodash directory that contains a <code class="md-code md-code-inline">uniqueId.js</code> file.</p> <pre class="md-code-block"><code class="md-code">| __mocks__
| + lodash
|   + uniqueId.js
| node_modules
</code></pre> <p>Inside, <code class="md-code md-code-inline">uniqueId.js</code> export either your <code class="md-code md-code-inline">mockImplementation</code> or your <code class="md-code md-code-inline">mockReturnValue</code>. The only difference is that you have to create a <code class="md-code md-code-inline">jest.fn()</code> first. It&#x2019;s not strictly required that you return <code class="md-code md-code-inline">jest.fn()</code> you can just return any function. However, by returning a mocked <code class="md-code md-code-inline">jest.fn()</code> you have more options to change the return value (more on that in a bit).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-keyword">default</span> jest.fn().mockImplementation(() =&gt; <span class="md-code-string">&apos;1&apos;</span>)
</code></pre> <p>Now that you have mocked the function at the <code class="md-code md-code-inline">import</code> level, you don&#x2019;t need to do anything in your actual test. The mock is detected for you.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { createEmployee, } from <span class="md-code-string">&apos;./utils.next&apos;</span>

describe(<span class="md-code-string">&apos;createEmployee&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should create a blank employee&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank = createEmployee()
    <span class="md-code-keyword">const</span> expected = {
      name: <span class="md-code-string">&apos;&apos;</span>,
      position: <span class="md-code-string">&apos;&apos;</span>,
      key: <span class="md-code-string">&apos;1&apos;</span>
    }

    expect(blank).toEqual(expected)
  })

  <span class="md-code-comment">// Other tests</span>

})
</code></pre> <h3 id="changing-on-the-fly">Changing on the fly</h3> <p>Of course, if you want to change if for an individual test you can still do so. Suppose you had a helper function that sorts the employees by key. This would, essentially, reset the order.</p> <p>The function is pretty straightforward:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sortEmployees</span><span class="md-code-params">(employees)</span> </span>{
  <span class="md-code-keyword">return</span> [...employees].sort((a,b) =&gt; <span class="md-code-built_in">Number</span>(a.key) - <span class="md-code-built_in">Number</span>(b.key))
}
</code></pre> <p>This makes testing a little more tricky. Remember, you just mocked the function so it always returns the same value. And that is good for all the previous tests, but now you need the few <em>different</em> unique ids.</p> <p>Fortunately, once you have it mocked, it&#x2019;s easy to make changes at runtime&#x2026; As a reminder here&#x2019;s the mock in <code class="md-code md-code-inline">__mocks__/lodash/uniqueId.js</code>:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-keyword">default</span> jest.fn().mockImplementation(() =&gt; <span class="md-code-string">&apos;1&apos;</span>)
</code></pre> <p>The important thing is that you are exporting a jest function. That means you can import that mocked function and change it on the fly.</p> <p>First, import <code class="md-code md-code-inline">uniqueId</code> into your test:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import uniqueId from <span class="md-code-string">&apos;lodash/uniqueId&apos;</span>
</code></pre> <p>Now, in your test anytime you want to change the value, you declare what you want it to return. As a safety, use the method <code class="md-code md-code-inline">mockImplementationOnce</code> this will ensure that the method will only return the alternate value, well, once. Then it will return to the original mock implementation. This will prevent some confusing bugs from sneaking into your code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import uniqueId from <span class="md-code-string">&apos;lodash/uniqueId&apos;</span>

uniqueId.mockImplementationOnce(() =&gt; <span class="md-code-string">&apos;2&apos;</span>)

uniqueId()
<span class="md-code-comment">// 2</span>

uniqueId()
<span class="md-code-comment">// 1</span>
</code></pre> <p>With this power you can create a few employees with different unique ids. After that the test is simple:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { createEmployee, sortEmployees } from <span class="md-code-string">&apos;./utils.next&apos;</span>
import uniqueId from <span class="md-code-string">&apos;lodash/uniqueId&apos;</span>

describe(<span class="md-code-string">&apos;createEmployee&apos;</span>, () =&gt; {
  <span class="md-code-comment">// &#x2026; tests</span>

  it(<span class="md-code-string">&apos;should sort employees by id&apos;</span>, () =&gt; {
    <span class="md-code-keyword">const</span> blank1 = createEmployee({ name: <span class="md-code-string">&apos;Olivia&apos;</span>})

    uniqueId.mockImplementationOnce(() =&gt; <span class="md-code-string">&apos;2&apos;</span>)
    <span class="md-code-keyword">const</span> blank2 = createEmployee({ firstName: <span class="md-code-string">&apos;Xander&apos;</span>})

    uniqueId.mockImplementationOnce(() =&gt; <span class="md-code-string">&apos;3&apos;</span>)
    <span class="md-code-keyword">const</span> blank3 = createEmployee({ name: <span class="md-code-string">&apos;Bill&apos;</span> })

    <span class="md-code-keyword">const</span> expected = [<span class="md-code-string">&apos;Olivia&apos;</span>, <span class="md-code-string">&apos;Xander&apos;</span>, <span class="md-code-string">&apos;Bill&apos;</span>]
    <span class="md-code-keyword">const</span> employees = [blank2, blank3, blank1]

    <span class="md-code-keyword">const</span> mapped = sortEmployees(employees).map(employee =&gt; employee.name)

   expect(mapped).toEqual(expected)
  })

  <span class="md-code-comment">// &#x2026; more tests</span>
})
</code></pre> <p>In this situation, you are creating different unique ids for only this one specific set of assertions. Everything else falls back to the predictable unique id.</p> <h3 id="ignoring-black-boxes">Ignoring Black Boxes</h3> <p>There&#x2019;s more ways you can use <code class="md-code md-code-inline">mockImplementation</code> to change or modify individual library methods. But occasionally, you want to completely remove a piece of external code. You may have a heavy piece of code that itself has a large number of external dependencies. Rather than import the large code, it may be easier to bypass it altogether. This is a good technique when you have a piece of code that&#x2019;s indepedent from the rest of the code, but still is included.</p> <p>In other words, whenever a sales or marketing person forwards you an email with code you &#x201C;just have to drop in&#x201D;&#x200A;&#x2014;&#x200A;a tracking pixel, a buy now widget or so on&#x200A;&#x2014;&#x200A;you may have something you need to ignore.</p> <p>Suppose you have a piece of code that adds a map of some sort. Assume the stripped down version of the code you are importing looks something like this:</p> <pre class="md-code-block"><code class="md-code md-lang-xml">const tiles = [...Array(1000)].map(() =&gt; &apos;<span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>&#x1F384;<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>&apos;)
const container = `
  <span class="md-code-tag">&lt;<span class="md-code-title">div</span> <span class="md-code-attribute">class</span>=<span class="md-code-value">&quot;container&quot;</span>&gt;</span>${tiles.join(&apos;&apos;)}<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
`

export default function render() {
  const mapContainer = document.querySelector(&apos;#map&apos;)
  mapContainer.innerHTML = container
}
</code></pre>
<p>Nothing too difficult here, but it does make a few assumptions about the DOM. It runs a <code class="md-code md-code-inline">querySelector</code> and expect to see the <code class="md-code md-code-inline">innerHTML</code>.</p>
<p>Suppose that you have a small React component that list some ride options and also renders the map. The map is effectively an image as far as you are concerned. You just need to make sure that a <code class="md-code md-code-inline">div</code> exists so you can add the map to it at runtime.</p>
<pre class="md-code-block"><code class="md-code md-lang-xml">import React, { useEffect } from &apos;react&apos;
import renderMap from &apos;streetMap&apos;

export default function RideFinder({ rides }) {
  useEffect(() =&gt; {
    renderMap()
  }, [])
  return (
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">h3</span>&gt;</span>Find a Ride<span class="md-code-tag">&lt;/<span class="md-code-title">h3</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">ul</span>&gt;</span>
        {rides.map(ride =&gt; <span class="md-code-tag">&lt;<span class="md-code-title">li</span> <span class="md-code-attribute">key</span>=<span class="md-code-value">{ride.id}</span>&gt;</span>{ride.name}<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>)}
      <span class="md-code-tag">&lt;/<span class="md-code-title">ul</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">div</span> <span class="md-code-attribute">id</span>=<span class="md-code-value">&quot;map&quot;</span>&gt;</span><span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  )
}
</code></pre>
<p>In your test, you don&#x2019;t care about the map. It&#x2019;s a blackbox, but you do want to make sure you are creating the correct number of list items.</p>
<pre class="md-code-block"><code class="md-code md-lang-xml">import React from &apos;react&apos;
import { mount } from &apos;enzyme&apos;
import RideFinder from &apos;./RideFinder&apos;

function flushPromises() {
  return new Promise(resolve =&gt; setTimeout(resolve, 10))
}

describe(&apos;RideFinder&apos;, () =&gt; {
  const rides = [
    {
      name: &apos;River Trail&apos;,
      id: 1,
    },
    {
      name: &apos;Downtown Bikepath&apos;,
      id: 2,
    }
  ]

  it(&apos;should render ride finder&apos;, async () =&gt; {
    const wrapper = mount(<span class="md-code-tag">&lt;<span class="md-code-title">RideFinder</span> <span class="md-code-attribute">rides</span>=<span class="md-code-value">{rides}</span>/&gt;</span>)
    const renderedRides = wrapper.find(&apos;li&apos;)
    await flushPromises()
    expect(renderedRides.length).toBe(2)
  })
})
</code></pre>
<p>Note there are a few complications. To make sure <code class="md-code md-code-inline">useEffect</code> runs in enzyme, you need a small timeout to ensure everything finishes rendering. There are <a href="https://www.github.com/kentcdodds/react-testing-library" target="_blank" rel="noopener noreferrer" aria-label="react-testing-library on GitHub">other testing options than <code class="md-code md-code-inline">enzyme</code></a>, but <code class="md-code md-code-inline">enzyme</code> remains popular.</p>
<p>After running this code, you get an error:</p>
<p><code class="md-code md-code-inline">Uncaught TypeError: Cannot set property &apos;innerHTML&apos; of null</code></p>
<p>The DOM manipulations are causing problems. In this case, you may want to mock out the map code.</p>
<p>As with <code class="md-code md-code-inline">lodash</code> above, make a file of the same name as the module in the <code class="md-code md-code-inline">__mocks__</code> directory. In this case, you are using the main default, to you don&#x2019;t need an additional directory. Together, it would look like this:</p>
<pre class="md-code-block"><code class="md-code">| __mocks__
| + lodash
|   + uniqueId.js
| + streetMap.js
| node_modules
</code></pre>
<p>Inside of <code class="md-code md-code-inline">streetMap.js</code> simply return a mock function. Remember, in this case, you don&#x2019;t really care what it does. You just want to make sure it runs.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-keyword">default</span> jest.fn()
</code></pre>
<p>At this point, your test will run with no problems. However, if you want to ensure that the your code will run the blackbox, even though you don&#x2019;t care about the output, you can still assert that it works. As with Lodash, import the code you want to check, then add an expect function to see if it is called:</p>
<pre class="md-code-block"><code class="md-code md-lang-xml">import React from &apos;react&apos;
import { mount } from &apos;enzyme&apos;
import RideFinder from &apos;./RideFinder&apos;
import renderMap from &apos;streetMap&apos;

function flushPromises() {
  return new Promise(resolve =&gt; setTimeout(resolve, 10))
}

describe(&apos;RideFinder&apos;, () =&gt; {
  const rides = [
    {
      name: &apos;River Trail&apos;,
      id: 1,
    },
    {
      name: &apos;Downtown Bikepath&apos;,
      id: 2,
    }
  ]

  it(&apos;should render ride finder&apos;, async () =&gt; {
    const wrapper = mount(<span class="md-code-tag">&lt;<span class="md-code-title">RideFinder</span> <span class="md-code-attribute">rides</span>=<span class="md-code-value">{rides}</span>/&gt;</span>)
    await flushPromises()
    expect(renderMap).toBeCalled()
  })
})
</code></pre>
<p>You now have a test that ensures that blackbox code is called while preventing the code from running itself. Since you have no control over the code, and it is fairly independent, this is a good strategy to ensure coverage without overcomplicating your test suite.</p>
<h3 id="using-mocks-responsibly">Using mocks responsibly</h3>
<p>Mocks give you a lot of power to bypass code. However, that power can also be dangerous. As soon as you bypass code, you are creating tests that do not fully execute your code. If you make false assumptions in your mocks, errors will begin to sneak into your code. And I can tell you from experience, this can happen quickly and tracking it down can be frustrating.</p>
<p>As a rule, only use mocks in situations where the side effect is <em>very</em> isolated. As you can see with the Lodash functions, you don&#x2019;t want to mock everything, just the piece that causes problems. If you use other Lodash methods, you want to ensure they run properly.</p>
<p>Same with the blackbox code. Nothing in the rest of your code is dependent on the results. So you can safely mock it out without creating too many additional assumptions in your tests.</p>
<p>Mocks can be a powerful tool that can get you more code coverage with a simple interface. Use them with caution, but use them confidently when you do.</p></div>

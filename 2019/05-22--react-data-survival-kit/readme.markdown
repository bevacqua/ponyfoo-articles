<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/react-data-survival-kit">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/react-data-survival-kit"><div><img src="https://images.ponyfoo.com/uploads/photo-1502899137071-8a43139a71a9-a1ed7aa6da384909b3be52ce7a2eb2d6.jpeg" alt="React Data Survival Kit"></div></a>

<h1>React Data Survival Kit</h1>

<p><kbd>react</kbd> <kbd>data</kbd> <kbd>state</kbd> <kbd>hooks</kbd> <kbd>refs</kbd> <kbd>autosave</kbd></p>

<blockquote><p>Learn how to handle data inside of React with this collection of patterns for fetching, storing, and retrieving data in React.</p>
</blockquote>

<div><p>Handling data in React can be treacherous if you don&#x2019;t know your way around. Learn some common patterns for fetching, storing, and retrieving data in this guide to help you avoid messy code traps.</p></div>

<blockquote></blockquote>

<div><p>React&#x2019;s flexibility means you can handle data in a lot of different ways. This guide will teach you patterns for fetching, storing, and retrieving data in React without the stress of maintaining a complex system.</p></div>

<div><p>As part of <a href="https://cleverbeagle.com/" target="_blank" rel="noopener noreferrer">my mentorship business</a>, I have the unique opportunity to work with React daily across a wide range of projects. Teaching others how to build their own software products, I&#x2019;ve come to find that most problems in React can be solved with some very simple techniques.</p> <p>While some cases may call for a full-blown architecture using something like Redux (or other fanciness), a lot of the time React&#x2019;s built-in lifecycle methods and local state do the trick. In my opinion, the mark of a really great developer is one who can solve a problem with as few moving parts as possible. While it can feel great to build a monument to engineering in the form of a complex system, often it&#x2019;s just overkill.</p> <p>In this tutorial, I&#x2019;m going to share what I call my &#x201C;data survival kit:&#x201D; the most common patterns and hacks I use in my day-to-day work for managing data. By the time you finish, you&#x2019;ll have everything you need to build data-driven UIs that offer a polished user experience.</p> <h1 id="loading-data-via-hooks">Loading Data via Hooks</h1> <p>As most folks are building &#x201C;database apps,&#x201D; loading data is arguably one of the most common tasks to perform. Ultimately, where your data is coming from dictates your need for this. This pattern is best utilized in apps using a REST API or an RPC (remote procedure call) to fetch data.</p> <p>For example, if you&#x2019;re loading data via GraphQL, it&#x2019;s likely that you&#x2019;ll use this technique sparingly (e.g., when you need to fetch data programmatically as opposed to on page load), relying on tools like Apollo to load your data for you.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React, { useEffect, useState } from <span class="md-code-string">&apos;react&apos;</span>;

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Posts</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">const</span> [posts, setPosts] = useState([]);

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getData</span><span class="md-code-params">()</span> </span>{
    fetch(<span class="md-code-string">&apos;https://jsonplaceholder.typicode.com/posts&apos;</span>).then(async (fetchedPosts) =&gt; {
      <span class="md-code-keyword">const</span> postsAsJson = await fetchedPosts.json();
      setPosts(postsAsJson);
    });
  }

  useEffect(() =&gt; {
    getData();
    <span class="md-code-keyword">const</span> pollForData = setInterval(() =&gt; getData(), <span class="md-code-number">5000</span>);
    <span class="md-code-keyword">return</span> () =&gt; {
      clearTimeout(pollForData);
    };
  }, []);

  <span class="md-code-keyword">return</span> (
    <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">h4</span>&gt;</span>Posts<span class="md-code-tag">&lt;/<span class="md-code-title">h4</span>&gt;</span>
      {posts.map(({ id, title, body }) =&gt; (
        <span class="md-code-tag">&lt;<span class="md-code-title">div</span> <span class="md-code-attribute">key</span>=<span class="md-code-value">{id}</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">h3</span>&gt;</span>{title}<span class="md-code-tag">&lt;/<span class="md-code-title">h3</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">p</span>&gt;</span>{body}<span class="md-code-tag">&lt;/<span class="md-code-title">p</span>&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
      ))}
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  );
}

export default Posts;
</span></code></pre> <p>This example is relatively new but is ultimately just a refactor of a previous approach where you&#x2019;d use <code class="md-code md-code-inline">componentWillMount()</code> or <code class="md-code md-code-inline">componentDidMount()</code> to use React&#x2019;s new hooks feature. The idea is simple here: when our component loads into memory, go and fetch the data it will need and put it onto state.</p> <p>To make this work, we leverage the <code class="md-code md-code-inline">useEffect()</code> hook to say &#x201C;when our component loads, get our data and then set up a poll interval to refetch every five seconds.&#x201D; <code class="md-code md-code-inline">useEffect()</code> is essential, here, because side effects (e.g., fetching data) are not allowed in the body of a functional component due to their ability to produce &#x201C;confusing bugs and inconsistencies in the UI.&#x201D;</p> <p>The idea at play here is that <code class="md-code md-code-inline">useEffect()</code> will allow us to update the state of our functional component via the <code class="md-code md-code-inline">updatePosts()</code> method returned from our call to the <code class="md-code md-code-inline">useState()</code> hook. To prevent <code class="md-code md-code-inline">useEffect()</code> from running on every render of our component, we pass an empty array <code class="md-code md-code-inline">[]</code> as its second argument (this can contain values to conditionally fire <code class="md-code md-code-inline">useEffect()</code> when they change&#x2014;<a href="https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect" target="_blank" rel="noopener noreferrer">learn more here</a>).</p> <p>In order to clear out the interval when our component unmounts, <code class="md-code md-code-inline">useEffect()</code> accepts a return value of <a href="https://reactjs.org/docs/hooks-reference.html#cleaning-up-an-effect" target="_blank" rel="noopener noreferrer">a &#x201C;clean up&#x201D; function</a> (this function behaves similar to <code class="md-code md-code-inline">componentWillUnmount()</code> in a class). The end result is that our data will be fetched and put onto state when our component initially loads and again every five seconds until our component unmounts.</p> <p>The reason I like this pattern is that it makes data fetching easy to understand for beginners and veterans alike. It also makes tasks like polling/refetching to keep data up to date easy&#x2014;no need to call to an out-of-scope refetch function or Redux action. Technically speaking, too, this is handy because it helps us to avoid getting tangled up in global state&#x2014;something that should only be used if it&#x2019;s absolutely necessary.</p> <h1 id="autosaving-using-state">Autosaving Using State</h1> <p>As applications have evolved, features like &#x201C;autosave&#x201D; have become common enough for users to expect them. Fortunately, React&#x2014;and by proxy, it&#x2019;s state&#x2014;makes this sort of feature painless for us to implement.</p> <p>The way I like to accomplish this is by write input changes to state directly (a controlled component) and then after a delay, make a call to write to the database. Depending on the UI and the amount of data involved, I&#x2019;ll either send up a <code class="md-code md-code-inline">PATCH</code> for an individual field, or, a <code class="md-code md-code-inline">PUT</code> for the entire object it&#x2019;s part of.</p> <p>For the delay, I like to use this <code class="md-code md-code-inline">delay</code> function that I picked up a few years ago&#x2014;it&#x2019;s simple and has served its purpose well:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> delay = (() =&gt; {
  <span class="md-code-keyword">let</span> timer = <span class="md-code-number">0</span>;
  <span class="md-code-keyword">return</span> (callback, ms) =&gt; {
    clearTimeout(timer);
    timer = setTimeout(callback, ms);
  };
})();
</code></pre> <p>The basic premise of this function is that it&#x2019;s a self-clearing <code class="md-code md-code-inline">setTimeout()</code>. So, when it&#x2019;s called, if it&#x2019;s called again before it&#x2019;s timeout <code class="md-code md-code-inline">ms</code>, it clears itself to avoid overflowing JavaScript&#x2019;s call stack. After the specified delay in ms has passed, the function performs like a regular <code class="md-code md-code-inline">setTimeout</code>, executing the code it contains (i.e., once a user stops typing for 3000ms, <em>then</em> make the call).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> UserProfile extends React.Component {
  state = {};

  handleLiveUpdate = (event) =&gt; {
    <span class="md-code-keyword">const</span> { name, value } = event;
    <span class="md-code-keyword">const</span> { updateProfile } = <span class="md-code-keyword">this</span>.props;

    <span class="md-code-keyword">this</span>.setState({ [name]: value }, () =&gt; {
      <span class="md-code-comment">// After handleLiveUpdate has stopped being called for 3 seconds, call to update database.</span>
      delay(() =&gt; {
        <span class="md-code-comment">// Example #1: Updating the database via GraphQL mutation.</span>
        updateProfile({
          variables: {
            [name]: value,
          },
        });

        <span class="md-code-comment">// Example #2: Updating the database via Meteor Method.</span>
        Meteor.call(<span class="md-code-string">&apos;users.updateProfile&apos;</span>, { [name]: value }, (error) =&gt; {
          <span class="md-code-keyword">if</span> (error) {
            alert(error.reason);
          }
        });

        <span class="md-code-comment">// Example #3: Updating the database via HTTP PATCH.</span>
        fetch(<span class="md-code-string">&apos;https://app.com/api/users&apos;</span>, {
          method: <span class="md-code-string">&apos;PATCH&apos;</span>,
          body: <span class="md-code-built_in">JSON</span>.stringify({ [name]: value }),
        });
      }, <span class="md-code-number">3000</span>);
    });
  };

  render() {
    <span class="md-code-keyword">return</span> (
      <span><span class="md-code-tag">&lt;<span class="md-code-title">form</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">h4</span>&gt;</span>User Profile<span class="md-code-tag">&lt;/<span class="md-code-title">h4</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;firstName&quot;</span>&gt;</span>First Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;firstName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.firstName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleLiveUpdate}</span> /&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;lastName&quot;</span>&gt;</span>Last Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;lastName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.lastName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleLiveUpdate}</span> /&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;emailAddress&quot;</span>&gt;</span>Email Address<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;email&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;emailAddress&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.emailAddress}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleLiveUpdate}</span> /&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">form</span>&gt;</span>
    );
  }
}
</span></code></pre> <p>The idea here is that as the user makes changes to the form we want to autosave, we immediately set state. Then, in the &#x201C;background,&#x201D; we utilize the <code class="md-code md-code-inline">delay()</code> function to say &#x201C;after they&#x2019;ve stopped typing, persist the current state in the database.&#x201D; The database part depends on how you handle data in your application.</p> <p>Because I spend a lot of my time <a href="https://cleverbeagle.com/pup" target="_blank" rel="noopener noreferrer">working in Meteor and GraphQL with the boilerplate I maintain, Pup</a>, I&#x2019;ll either use Meteor&#x2019;s <code class="md-code md-code-inline">Meteor.call()</code> convention to send my data to the server for storage, or, <a href="https://ponyfoo.com/articles/graphql-in-depth-what-why-and-how#understanding-mutations" target="_blank" rel="noopener noreferrer">call to a mutation</a> if I&#x2019;m relying on GraphQL. If I&#x2019;m building a mobile app, I&#x2019;ll rely on <code class="md-code md-code-inline">fetch()</code> or a library like <code class="md-code md-code-inline">axios()</code> to talk to my REST API.</p> <h1 id="using-local-storage-to-persist-unsaved-data">Using Local Storage to Persist Unsaved Data</h1> <p>One of the worst bits of UX is having a large form without a backup. As a user, there&#x2019;s nothing quite as disheartening as filling out a large form and accidentally hitting refresh to find all of your work is gone.</p> <p>Fortunately, the trick to getting around this is pretty simple (and utilizes a similar approach to the autosave example above). This pattern necessitates that our data live on our component&#x2019;s state, allowing us to maintain the illusion of a user&#x2019;s data being persisted without hitting a database.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import store from <span class="md-code-string">&apos;store&apos;</span>;

<span class="md-code-keyword">class</span> UserProfile extends React.Component {
  constructor(props) {
    super(props);
    <span class="md-code-keyword">this</span>.state = store.get(<span class="md-code-string">&apos;myApp.userProfile&apos;</span>) || {};
  }

  handleUpdate = (event) =&gt; {
    <span class="md-code-keyword">const</span> { name, value } = event;

    <span class="md-code-keyword">this</span>.setState({ [name]: value }, () =&gt; {
      delay(() =&gt; {
        store.set(<span class="md-code-string">&apos;myApp.userProfile&apos;</span>, <span class="md-code-keyword">this</span>.state);
      }, <span class="md-code-number">500</span>);
    });
  };

  render() {
    <span class="md-code-keyword">return</span> (
      <span><span class="md-code-tag">&lt;<span class="md-code-title">form</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">h4</span>&gt;</span>User Profile<span class="md-code-tag">&lt;/<span class="md-code-title">h4</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;firstName&quot;</span>&gt;</span>First Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;firstName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.firstName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;lastName&quot;</span>&gt;</span>Last Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;lastName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.lastName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;emailAddress&quot;</span>&gt;</span>Email Address<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;email&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;emailAddress&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.emailAddress}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">form</span>&gt;</span>
    );
  }
}
</span></code></pre> <p>This should look pretty familiar. Everything here is identical to the autosave approach save for a few small details.</p> <p>First, we&#x2019;ve introduced a library <code class="md-code md-code-inline">store</code> which will help us to get cross-browser access to local storage (or a comparable browser cache that&#x2019;s available to our user). Our usage of the library is limited to two calls: one when we load our component/page up for the first time and whenever a user changes their data.</p> <p>The first takes place in our component&#x2019;s <code class="md-code md-code-inline">constructor()</code> function. Here, we&#x2019;re setting our default state value relative to the current value of our local storage key (here, <code class="md-code md-code-inline">myApp.userProfile</code> is the name of the key we&#x2019;ve chosen to store our data in local storage). What we expect is that <code class="md-code md-code-inline">store.get()</code> will return an object containing properties that reflect the state values our UI requires.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">  handleUpdate = (event) =&gt; {
    <span class="md-code-keyword">const</span> { name, value } = event;

    <span class="md-code-keyword">this</span>.setState({ [name]: value }, () =&gt; {
      delay(() =&gt; {
        store.set(<span class="md-code-string">&apos;myApp.userProfile&apos;</span>, <span class="md-code-keyword">this</span>.state);
      }, <span class="md-code-number">500</span>);
    });
  };
</code></pre> <p>In order to get those values into local storage, we use a <code class="md-code md-code-inline">handleUpdate</code> method on our component that uses the same approach to our autosave pattern. Here, we immediately set the user&#x2019;s input on state and then after a short delay, we update the local storage value via <code class="md-code md-code-inline">store.set(&apos;myApp.userProfile&apos;, this.state)</code>.</p> <p>Two details here: notice that we&#x2019;ve reduced our delay significantly to <code class="md-code md-code-inline">500ms</code>. This is because it&#x2019;s far less expensive to hit our local storage than it is to make a trip to the server. Also, notice that we&#x2019;re setting the entirety of the current <code class="md-code md-code-inline">this.state</code> value onto local storage when we change any input. This, too, is inexpensive for performance and also saves us a messy <code class="md-code md-code-inline">constructor()</code> loaded with calls to <code class="md-code md-code-inline">store.get()</code> for each individual field.</p> <h1 id="reaching-into-a-child-component-via-refs">Reaching Into a Child Component via Refs</h1> <p>One of the bittersweet features of React is the ability to nest child components. It&#x2019;s bittersweet because while it makes composition easy&#x2014;bringing together multiple components in a cohesive UI&#x2014;it can make tasks like getting data out of child components a chore.</p> <p>A simple hack that I like to leverage for this is accessing child components via refs. While it&#x2019;s more common to pass a function via props to a child component that handles tracking the child&#x2019;s state on the parent (or at least, notifying the parent when its internal state changes), this can get messy and cumbersome.</p> <p>Instead, if all we care to know is the current internal state of a child component, refs make our lives a hell of a lot easier. Let&#x2019;s consider the example of a job application. We have some basic form fields we&#x2019;d like to grab along with two lists: the candidates strengths and weaknesses.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;

<span class="md-code-keyword">class</span> List extends React.Component {
  state = {
    items: [],
  };

  handleRemoveItem = (id) =&gt; {
    <span class="md-code-keyword">this</span>.setState(({ items }) =&gt; ({
      items: items.filter((item) =&gt; item.id !== id),
    }));
  };

  handleAddItem = (event) =&gt; {
    event.persist(); <span class="md-code-comment">// Use event.persist() so we don&apos;t lose React synthetic event in nested function below.</span>
    <span class="md-code-keyword">this</span>.setState(({ items }) =&gt; ({
      <span class="md-code-comment">// randomIdGenerator() is used for example here and doesn&apos;t exist.</span>
      items: [...items, { id: randomIdGenerator(), item: event.item.value }],
    }));
  };

  render() {
    <span class="md-code-keyword">return</span> (
      <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
        {this.state.items.map(({ id, item }) =&gt; (
          <span class="md-code-tag">&lt;<span class="md-code-title">li</span> <span class="md-code-attribute">key</span>=<span class="md-code-value">{id}</span>&gt;</span>
            {item}
            <span class="md-code-tag">&lt;<span class="md-code-title">button</span> <span class="md-code-attribute">onClick</span>=<span class="md-code-value">{()</span> =&gt;</span> this.handleRemoveItem(id)}&gt;
              <span class="md-code-tag">&lt;<span class="md-code-title">i</span> <span class="md-code-attribute">className</span>=<span class="md-code-value">&quot;fas fa-remove&quot;</span> /&gt;</span>
            <span class="md-code-tag">&lt;/<span class="md-code-title">button</span>&gt;</span>
          <span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>
        ))}
        <span class="md-code-tag">&lt;<span class="md-code-title">form</span> <span class="md-code-attribute">onSubmit</span>=<span class="md-code-value">{this.handleAddItem}</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;item&quot;</span> /&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">button</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;submit&quot;</span>&gt;</span>Add Item<span class="md-code-tag">&lt;/<span class="md-code-title">button</span>&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">form</span>&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
    );
  }
}
</span></code></pre> <p>To manage those two lists, we use a nested component with its own state called <code class="md-code md-code-inline">&lt;List /&gt;</code>. Internally, the component gives the applicant an input to add as many list items as they choose. As a standalone component, this doesn&#x2019;t present us with any issues.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import List from <span class="md-code-string">&apos;./path/to/List&apos;</span>;

<span class="md-code-keyword">class</span> JobApplication extends React.Component {
  state = {
    firstName: <span class="md-code-string">&apos;&apos;</span>,
    lastName: <span class="md-code-string">&apos;&apos;</span>,
    emailAddress: <span class="md-code-string">&apos;&apos;</span>,
  };

  handleSubmitApplication = (event) =&gt; {
    <span class="md-code-keyword">const</span> { submitApplication } = <span class="md-code-keyword">this</span>.props;

    <span class="md-code-comment">// Example call to a GraphQL mutation here to perform the submission.</span>
    submitApplication({
      variables: {
        ...this.state,
        strengths: <span class="md-code-keyword">this</span>.strengths.state.items,
        weaknesses: <span class="md-code-keyword">this</span>.weaknesses.state.items,
      },
    });
  };

  render() {
    <span class="md-code-keyword">return</span> (
      <span><span class="md-code-tag">&lt;<span class="md-code-title">React.Fragment</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">h1</span>&gt;</span>Job Application<span class="md-code-tag">&lt;/<span class="md-code-title">h1</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">form</span> <span class="md-code-attribute">onSubmit</span>=<span class="md-code-value">{this.handleSubmitApplication}</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;firstName&quot;</span>&gt;</span>First Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;firstName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.firstName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
          <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;lastName&quot;</span>&gt;</span>Last Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;lastName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.lastName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
          <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;emailAddress&quot;</span>&gt;</span>Email Address<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;email&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;emailAddress&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.emailAddress}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
          <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span>&gt;</span>What are some of your strengths?<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">List</span> <span class="md-code-attribute">ref</span>=<span class="md-code-value">{strengths</span> =&gt;</span> (this.strengths = strengths)} /&gt;
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span>&gt;</span>What are some of your weaknesses?<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">List</span> <span class="md-code-attribute">ref</span>=<span class="md-code-value">{weaknesses</span> =&gt;</span> (this.weaknesses = weaknesses)} /&gt;
          <span class="md-code-tag">&lt;<span class="md-code-title">button</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;submit&quot;</span>&gt;</span>Submit Job Application<span class="md-code-tag">&lt;/<span class="md-code-title">button</span>&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">form</span>&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">React.Fragment</span>&gt;</span>
    );
  }
}
</span></code></pre> <p>Where things can potentially get messy is when we render the <code class="md-code md-code-inline">&lt;List /&gt;</code> component inside of a parent. Here, <code class="md-code md-code-inline">&lt;JobApplication /&gt;</code> represents that parent. In the <code class="md-code md-code-inline">render()</code> we can see two instances of <code class="md-code md-code-inline">&lt;List /&gt;</code> being generated.</p> <p>Traditionally, we could add a prop to <code class="md-code md-code-inline">&lt;List /&gt;</code> called <code class="md-code md-code-inline">onUpdate()</code> that was called internally by <code class="md-code md-code-inline">&lt;List /&gt;</code> passing up the current items. Where this becomes problematic is in having to track the list&#x2019;s state both internally as well as on the parent (or having the parent feed the child its data&#x2014;no bueno unless we need to load data from the database).</p> <p>To simplify this, we add a <code class="md-code md-code-inline">ref</code> to each instance of the <code class="md-code md-code-inline">&lt;List /&gt;</code>, assigning it back to our <code class="md-code md-code-inline">&lt;JobApplication /&gt;</code> component as either <code class="md-code md-code-inline">this.strengths</code> or <code class="md-code md-code-inline">this.weaknesses</code>. What&#x2019;s great about this is that now, we have direct access to these components from within <code class="md-code md-code-inline">&lt;JobApplication /&gt;</code>.</p> <p>When our applicant submits the form, all we need to do get its items is call to either <code class="md-code md-code-inline">this.strengths.state.items</code> or <code class="md-code md-code-inline">this.weaknesses.state.items</code>.</p> <h2 id="bonus-controlling-a-child-via-the-parent">Bonus: Controlling a Child via the Parent</h2> <p>You may be wondering, does this mean I can control the child component via refs as well? Yes. You want to be careful with this, however, as it can produce unexpected side effects. For example, when it comes to updating a component&#x2019;s internal state relative to a parent&#x2019;s data, it&#x2019;s best to pass changes via props.</p> <p>Sometimes, though, this isn&#x2019;t always feasible or wanted. For example, consider our example above. After the application is submitted, let&#x2019;s assume we want to &#x201C;reset&#x201D; the form. Because our <code class="md-code md-code-inline">&lt;List /&gt;</code> components maintain their state internally, this means we need to manipulate their state from <code class="md-code md-code-inline">&lt;JobApplication /&gt;</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import List from <span class="md-code-string">&apos;./path/to/List&apos;</span>;

<span class="md-code-keyword">class</span> JobApplication extends React.Component {
  state = {
    firstName: <span class="md-code-string">&apos;&apos;</span>,
    lastName: <span class="md-code-string">&apos;&apos;</span>,
    emailAddress: <span class="md-code-string">&apos;&apos;</span>,
  };

  handleSubmitApplication = (event) =&gt; {
    <span class="md-code-keyword">const</span> { submitApplication } = <span class="md-code-keyword">this</span>.props;

    <span class="md-code-comment">// Example call to a GraphQL mutation here to perform the submission.</span>
    submitApplication({
      variables: {
        ...this.state,
        strengths: <span class="md-code-keyword">this</span>.strengths.state.items,
        weaknesses: <span class="md-code-keyword">this</span>.weaknesses.state.items,
      },
    }).then(() =&gt; {
      <span class="md-code-keyword">this</span>.strengths.setState({ items: [] });
      <span class="md-code-keyword">this</span>.weaknesses.setState({ items: [] });
    });
  };

  render() {
    <span class="md-code-keyword">return</span> (
      <span><span class="md-code-tag">&lt;<span class="md-code-title">React.Fragment</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">h1</span>&gt;</span>Job Application<span class="md-code-tag">&lt;/<span class="md-code-title">h1</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">form</span> <span class="md-code-attribute">onSubmit</span>=<span class="md-code-value">{this.handleSubmitApplication}</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;firstName&quot;</span>&gt;</span>First Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;firstName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.firstName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
          <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;lastName&quot;</span>&gt;</span>Last Name<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;text&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;lastName&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.lastName}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
          <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">label</span> <span class="md-code-attribute">htmlFor</span>=<span class="md-code-value">&quot;emailAddress&quot;</span>&gt;</span>Email Address<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
            <span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;email&quot;</span> <span class="md-code-attribute">name</span>=<span class="md-code-value">&quot;emailAddress&quot;</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{this.state.emailAddress}</span> <span class="md-code-attribute">onChange</span>=<span class="md-code-value">{this.handleUpdate}</span> /&gt;</span>
          <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span>&gt;</span>What are some of your strengths?<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">List</span> <span class="md-code-attribute">ref</span>=<span class="md-code-value">{strengths</span> =&gt;</span> (this.strengths = strengths)} /&gt;
          <span class="md-code-tag">&lt;<span class="md-code-title">label</span>&gt;</span>What are some of your weaknesses?<span class="md-code-tag">&lt;/<span class="md-code-title">label</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">List</span> <span class="md-code-attribute">ref</span>=<span class="md-code-value">{weaknesses</span> =&gt;</span> (this.weaknesses = weaknesses)} /&gt;
          <span class="md-code-tag">&lt;<span class="md-code-title">button</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&quot;submit&quot;</span>&gt;</span>Submit Job Application<span class="md-code-tag">&lt;/<span class="md-code-title">button</span>&gt;</span>
        <span class="md-code-tag">&lt;/<span class="md-code-title">form</span>&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">React.Fragment</span>&gt;</span>
    );
  }
}
</span></code></pre> <p>Here, when our applicant submits the form, as soon as we get an &#x201C;all good&#x201D; back from the database, we call to <code class="md-code md-code-inline">this.strengths.setState()</code> and <code class="md-code md-code-inline">this.weaknesess.setState()</code> to reset their internal state.</p> <p>Again, use this wisely&#x2014;I consider this a hack which means it should be applied with caution and ample experimentation/testing.</p> <h2 id="conclusion">Conclusion</h2> <p>Using data in React doesn&#x2019;t need to be complicated. In fact, one of the joys of using React is that it can help you produce interactive UIs with very little effort. If you&#x2019;re already committed to React, it&#x2019;s worth considering how you might simplify your own use of it. More often than not, the problems I see in React applications involve unnecessarily complex data patterns.</p></div>

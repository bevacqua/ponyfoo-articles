<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8"><div><img src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/HERO-a65824e81d56460c923316ffdde171ba.jpg" alt="An Introduction to Speculative Optimization in V8"></div></a>

<h1>An Introduction to Speculative Optimization in V8</h1>

<p><kbd>v8</kbd> <kbd>javascript</kbd> <kbd>performance</kbd></p>

<blockquote><p>An impressively low-level article that we hope gives you a good idea about what happens in V8 when it comes to optimization.</p>
</blockquote>

<div><p>An impressively low-level article that we hope gives you a good idea about what happens in V8 when it comes to optimization.</p></div>

<blockquote><p>Once again, we have Benedikt Meurer in the house. Benedikt is the optimization lead in charge of V8 performance, and today he brings us a deep dive into how the TurboFan optimizing compiler in V8 works.</p><p align="right"><sub><em>&#x2014; Editor&#x2019;s note.</em></sub></p></blockquote>

<div><p>Following up on my talk <a href="https://www.youtube.com/watch?v=cvybnv79Sek" target="_blank" rel="noopener noreferrer">&#x201C;A Tale of TurboFan&#x201D;</a> (<a href="https://docs.google.com/presentation/d/1UXR1H2elTdAYJJ0Eed7lUctCVUserav9sAYSidxp8YE" target="_blank" rel="noopener noreferrer">slides</a>) at <a href="https://ponyfoo.com/2017.js-kongress.de">JS Kongress</a>, I wanted to give some additional context on how TurboFan, V8&#x2019;s optimizing compiler, works and how V8 turns your JavaScript into highly-optimized machine code. For the talk I had to be brief and leave out several details. So I&#x2019;ll use this opportunity to fill the gaps, especially how V8 collects and uses the profiling information to perform speculative optimizations.</p></div>

<div><h1 id="overview">Overview</h1> <p>Before we dive into the details of how TurboFan works, I&#x2019;ll briefly explain how V8 works on a high level. Let&#x2019;s have a look at this <em>simplified breakdown of how V8 works</em> (taken from the <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener noreferrer">&#x201C;JavaScript Start-up Performance&#x201D;</a> blog post by my colleague <a href="https://twitter.com/addyosmani" target="_blank" rel="noopener noreferrer">Addy Osmani</a>):</p> <figure><img alt="How V8 Works" title="addy.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/addy-ad3b2ea8f9be48a18c4bdad5041a3237.png"></figure> <p>Whenever Chrome or Node.js has to execute some piece of JavaScript, it passes the source code to V8. V8 takes that JavaScript source code and feeds it to the so-called <a href="https://en.wikipedia.org/wiki/Parsing#Computer_languages" target="_blank" rel="noopener noreferrer"><em>Parser</em></a>, which creates an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener noreferrer"><em>Abstract Syntax Tree (AST)</em></a> representation for your source code. The talk <a href="https://www.youtube.com/watch?v=Fg7niTmNNLg" target="_blank" rel="noopener noreferrer">&#x201C;Parsing JavaScript &#x2014; better lazy than eager?&#x201D;</a> from my colleague <a href="https://twitter.com/marjakh" target="_blank" rel="noopener noreferrer">Marja H&#xF6;ltt&#xE4;</a> contains some details of how this works in V8. The AST is then passed on to the recently introduced <a href="https://v8.dev/blog/ignition-interpreter" target="_blank" rel="noopener noreferrer">Ignition Interpreter</a>, where it is turned into a sequence of bytecodes. This sequence of bytecodes is then executed by Ignition.</p> <p>During execution, Ignition collects <em>profiling information</em> or <em>feedback</em> about the inputs to certain operations. Some of this feedback is used by Ignition itself to speed up subsequent interpretation of the bytecode. For example, for property accesses such as <code class="md-code md-code-inline">o.x</code>, where <code class="md-code md-code-inline">o</code> has the same shape all the time (i.e. you always pass a value <code class="md-code md-code-inline">{x:v}</code> for <code class="md-code md-code-inline">o</code> where <code class="md-code md-code-inline">v</code> is a String), we cache information on how to get to the value of <code class="md-code md-code-inline">x</code>. Upon subsequent execution of the same bytecode we don&#x2019;t need to search for <code class="md-code md-code-inline">x</code> in <code class="md-code md-code-inline">o</code> again. The underlying machinery here is called <a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener noreferrer"><em>inline cache (IC)</em></a>. You can find a lot of details about how this works for property accesses in the blog post <a href="http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener noreferrer">&#x201C;What&#x2019;s up with monomorphism?&#x201D;</a> by my colleague <a href="https://twitter.com/mraleph" target="_blank" rel="noopener noreferrer">Vyacheslav Egorov</a>.</p> <p>Probably even more important &#x2014; depending on your workload &#x2014; the <em>feedback</em> collected by the Ignition interpreter is consumed by the <a href="https://v8.dev/blog/launching-ignition-and-turbofan" target="_blank" rel="noopener noreferrer">TurboFan JavaScript compiler</a> to generate highly-optimized machine code using a technique called <em>Speculative Optimization</em>. Here the optimizing compiler looks at what kinds of values were seen in the past and assumes that in the future we&#x2019;re going to see the same kinds of values. This allows TurboFan to leave out a lot of cases that it doesn&#x2019;t need to handle, which is extremely important to execute JavaScript at peak performance.</p> <h1 id="the-basic-execution-pipeline">The Basic Execution Pipeline</h1> <p>Let&#x2019;s consider a reduced version of the example from my talk, focusing solely on the function <code class="md-code md-code-inline">add</code>, and how this is executed by V8.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span><span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">return</span> x + y;
}

<span class="md-code-built_in">console</span>.log(add(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>));
</code></pre> <p>If you run this in the Chrome DevTools console, you&#x2019;ll see that it outputs the expected result <code class="md-code md-code-inline">3</code>:</p> <figure><img alt="Chrome DevTools" title="devtools.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/devtools-b0e947b78ffc468c9599999c86bd08da.png"></figure> <p>Let&#x2019;s examine what happens under the hood in V8 to actually get to these results. We&#x2019;ll do this step by step for the function <code class="md-code md-code-inline">add</code>. As mentioned before, we first need to parse the function source code and turn that into an Abstract Syntax Tree (AST). This is done by the <code class="md-code md-code-inline">Parser</code>. You can see the AST that V8 generates internally using the <code class="md-code md-code-inline">--print-ast</code> command line flag in a Debug build of the <a href="https://v8.dev/docs/d8" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">d8 shell</code></a>.</p> <pre class="md-code-block"><code class="md-code">$ out/Debug/d8 --print-ast add.js
&#x2026;
--- AST ---
FUNC at 12
. KIND 0
. SUSPEND COUNT 0
. NAME &quot;add&quot;
. PARAMS
. . VAR (0x7fbd5e818210) (mode = VAR) &quot;x&quot;
. . VAR (0x7fbd5e818240) (mode = VAR) &quot;y&quot;
. RETURN at 23
. . ADD at 32
. . . VAR PROXY parameter[0] (0x7fbd5e818210) (mode = VAR) &quot;x&quot;
. . . VAR PROXY parameter[1] (0x7fbd5e818240) (mode = VAR) &quot;y&quot;
</code></pre> <p>This format is not very easy to consume, so let&#x2019;s visualize it.</p> <figure><img alt="Abstract Syntax Tree" title="ast.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/ast-602ed6f747124b0888c0a032eba50bb2.png"></figure> <p>Initially the function literal for <code class="md-code md-code-inline">add</code> is parsed into a tree representation, with one subtree for the parameter declarations and one subtree for the actual function body. During parsing it is impossible to tell which names correspond to which variables in the program, mostly due to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting" target="_blank" rel="noopener noreferrer"><em>funny <code class="md-code md-code-inline">var</code> hoisting rules</em></a> and <code class="md-code md-code-inline">eval</code> in JavaScript, but also for other reasons. So for every name the parser initially creates so-called <code class="md-code md-code-inline">VAR PROXY</code> nodes. The subsequent scope resolution step connects these <code class="md-code md-code-inline">VAR PROXY</code> nodes to the declaring <code class="md-code md-code-inline">VAR</code> nodes or marks them as either <em>global</em> or <em>dynamic lookups</em>, depending on whether the parser has seen an <code class="md-code md-code-inline">eval</code> expression in one of the surrounding scopes.</p> <p>Once this is done we have a complete AST that contains all the necessary information to generate executable bytecode from it. The AST is then passed to the <code class="md-code md-code-inline">BytecodeGenerator</code>, which is the part of the Ignition interpreter that generates bytecode on a per-function basis. You can also see the bytecode being generated by V8 using the flag <code class="md-code md-code-inline">--print-bytecode</code> with the <code class="md-code md-code-inline">d8</code> shell (or with <code class="md-code md-code-inline">node</code>).</p> <pre class="md-code-block"><code class="md-code">$ out/Debug/d8 --print-bytecode add.js
&#x2026;
[generated bytecode for function: add]
Parameter count 3
Frame size 0
   12 E&gt; 0x37738712a02a @    0 : 94                StackCheck
   23 S&gt; 0x37738712a02b @    1 : 1d 02             Ldar a1
   32 E&gt; 0x37738712a02d @    3 : 29 03 00          Add a0, [0]
   36 S&gt; 0x37738712a030 @    6 : 98                Return
Constant pool (size = 0)
Handler Table (size = 16)
</code></pre> <p>This tells us that a new bytecode object was generated for the function <code class="md-code md-code-inline">add</code>, which accepts three parameters: the implicit receiver <code class="md-code md-code-inline">this</code>, and the explicit formal parameters <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code>. The function doesn&#x2019;t need any local variables (the frame size is zero), and contains the sequence of four bytecodes:</p> <pre class="md-code-block"><code class="md-code">StackCheck
Ldar a1
Add a0, [0]
Return
</code></pre> <p>To explain that, we first need to understand how the interpreter works on a high level. Ignition uses a so-called <a href="https://en.wikipedia.org/wiki/Register_machine" target="_blank" rel="noopener noreferrer"><em>register machine</em></a> (in contrast to the <em>stack machine</em> approach that was used by earlier V8 versions in the FullCodegen compiler). It holds its local state in interpreter registers, some of which map to real CPU registers, while others map to specific slots in the native machine stack memory.</p> <figure><img alt="Interpreter overview" title="interpreter.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/interpreter-240fa989af5f41efb9b3c9776e8cb57c.png"></figure> <p>The special registers <code class="md-code md-code-inline">a0</code> and <code class="md-code md-code-inline">a1</code> correspond to the formal parameters for the function on the machine stack (in this case we have two formal parameters). Formal parameters are the parameters declared in the source code, which might be different from the actual number of parameters passed to the function at runtime. The last computed value of each bytecode is usually kept in a special register called the <code class="md-code md-code-inline">accumulator</code>, the current <em>stack frame</em> or <em>activation record</em> is identified by the <code class="md-code md-code-inline">stack pointer</code>, and the <code class="md-code md-code-inline">program counter</code> points to the currently executed instruction in the bytecode. Let&#x2019;s check what the individual bytecodes do in this example:</p> <ul> <li><code class="md-code md-code-inline">StackCheck</code> compares the <code class="md-code md-code-inline">stack pointer</code> to some known upper limit (actually a lower limit since the stack grows downwards on all architectures supported by V8). If the stack grows above a certain threshold, we abort execution of the function and throw a <code class="md-code md-code-inline">RangeError</code> saying that the stack was overflowed.</li> <li><code class="md-code md-code-inline">Ldar a1</code> loads the value of the register <code class="md-code md-code-inline">a1</code> into the <code class="md-code md-code-inline">accumulator</code> register (the name stands for <strong><em>LoaD Accumulator Register</em></strong>).</li> <li><code class="md-code md-code-inline">Add a0, [0]</code> loads the value from the <code class="md-code md-code-inline">a0</code> register and adds it to the value in the <code class="md-code md-code-inline">accumulator</code> register. The result is then placed into the <code class="md-code md-code-inline">accumulator</code> register again. Note that <em>addition</em> here can also mean string concatenation, and that this operation can execute <strong>arbitrary JavaScript</strong> depending on the operands. The <a href="https://tc39.github.io/ecma262/#sec-addition-operator-plus" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">+</code> operator</a> in JavaScript is really complex, and many people have tried to illustrate the complexity in talks. <a href="https://twitter.com/editingemily" target="_blank" rel="noopener noreferrer">Emily Freeman</a> recently gave a talk at JS Kongress titled <a href="https://www.youtube.com/watch?v=v8ToNvB-_Q8" target="_blank" rel="noopener noreferrer">&#x201C;JavaScript&#x2019;s &#x201C;+&#x201D; Operator and Decision Fatigue&#x201D;</a> on precisely this topic. The <code class="md-code md-code-inline">[0]</code> operand to the <code class="md-code md-code-inline">Add</code> operator refers to a <em>feedback vector slot</em>, where Ignition stores the profiling information about the values we&#x2019;ve seen during execution of the function. We&#x2019;ll get back to this later when we investigate how TurboFan optimizes the function.</li> <li><code class="md-code md-code-inline">Return</code> ends execution of the current function and transfers control back to the caller. The value returned is the current value in the <code class="md-code md-code-inline">accumulator</code> register.</li> </ul> <p>My colleague <a href="https://twitter.com/fhinkel" target="_blank" rel="noopener noreferrer">Franziska Hinkelmann</a> wrote an article <a href="https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775" target="_blank" rel="noopener noreferrer">&#x201C;Understanding V8&#x2019;s Bytecode&#x201D;</a> a while ago that gives some additional insight into how V8&#x2019;s bytecode works.</p> <h1 id="speculative-optimization">Speculative Optimization</h1> <p>Now that you have a rough understanding of how V8 executes your JavaScript in the baseline case, it&#x2019;s time to start looking into how TurboFan fits into the picture, and how your JavaScript code can be turned into highly optimized machine code. The <a href="https://tc39.github.io/ecma262/#sec-addition-operator-plus" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">+</code> operator</a> is already such a complex operation in JavaScript which has to do a lot of checks before it eventually does the number addition on the inputs.</p> <figure><img alt="Runtime Semantics of the + operator" title="add-operator.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/add-operator-dd7644f658044699893b02f3b56eccaf.png"></figure> <p>It&#x2019;s not immediately obvious how this can be done in just a few machine instructions to reach peak performance (comparable to Java or C++ code). The magic keyword here is <em>Speculative Optimization</em>, which makes use of assumptions about possible inputs. For example, when we know that in the case of <code class="md-code md-code-inline">x+y</code>, both <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code> are numbers, we don&#x2019;t need to handle the cases where either of them is a string, or even worse &#x2014; the case where the operands can be arbitrary JavaScript objects on which we need to run the abstract operation <a href="https://tc39.github.io/ecma262/#sec-toprimitive" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">ToPrimitive</code></a> first.</p> <figure><img alt="ToPrimitive operation" title="to-primitive.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/to-primitive-e3a448613a4b4188b123100424cad178.png"></figure> <p>Knowing that both <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code> are numbers also means that we can rule out observable side effects &#x2014; for example we know it cannot shut down the computer or write to a file or navigate to a different page. In addition we know that the operation won&#x2019;t throw an exception. Both of these are important for optimizations, because an optimizing compiler can only eliminate an expression if it knows for sure that this expression won&#x2019;t cause any observable side effects and doesn&#x2019;t raise exceptions.</p> <p>Due to the dynamic nature of JavaScript we usually don&#x2019;t know the precise types of values until runtime, i.e. just by looking at the source code it&#x2019;s often impossible to tell the possible values of inputs to operations. That&#x2019;s why we need to speculate, based on previously collected <em>feedback</em> about the values we&#x2019;ve seen so far, and then assume that we&#x2019;re going to always see similar values in the future. This might sound fairly limited, but it has proven to work well for dynamic languages like JavaScript.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span><span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">return</span> x + y;
}
</code></pre> <p>In this particular case, we collect information about the input operands and the resulting value of the + operation (the <code class="md-code md-code-inline">Add</code> bytecode). When we optimize this code with TurboFan and we&#x2019;ve seen only numbers so far, we put checks in place to check that both <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code> are numbers (in that case we know that the result is going to be a number as well). If either of these checks fail we go back to interpreting the bytecode instead &#x2014; a process called <em>Deoptimization</em>. Thus TurboFan doesn&#x2019;t need to worry about all these other cases of the <code class="md-code md-code-inline">+</code> operator and doesn&#x2019;t even need to emit machine code to handle those, but can focus on the case for numbers, which translates well to machine instructions.</p> <figure><img alt="Closure structure" title="closure.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/closure-6ab1198c716641f98cdced966e554611.png"></figure> <p>The feedback collected by Ignition is stored in the so-called <em>Feedback Vector</em> (previously named <em>Type Feedback Vector</em>). This special data structure is linked from the closure and contains slots to store different kinds of feedback, i.e. bitsets, closures or hidden classes, depending on the concrete <em>inline cache (IC)</em>. My colleague <a href="https://twitter.com/ripsawridge" target="_blank" rel="noopener noreferrer">Michael Stanton</a> gave a nice presentation at <a href="https://amsterdamjs.com/" target="_blank" rel="noopener noreferrer">AmsterdamJS</a> earlier this year titled <a href="https://www.youtube.com/watch?v=u7zRSm8jzvA" target="_blank" rel="noopener noreferrer">&#x201C;V8 and How It Listens to You&#x201D;</a>, which explains some of the concepts of the Feedback Vector in detail. The closure also links to the <em>SharedFunctionInfo</em>, which contains the general information about the function (like source position, bytecode, strict/sloppy mode, etc.), and there&#x2019;s a link to the <em>context</em> as well, which contains the values for the free variables of the function and provides access to the global object (i.e. the <code class="md-code md-code-inline">&lt;iframe&gt;</code> specific data structures).</p> <p>In the case of the add function, the Feedback Vector has exactly one interesting slot (in addition to the general slots like the call count slot), and this is a <code class="md-code md-code-inline">BinaryOp</code> slot, where binary operations like <code class="md-code md-code-inline">+</code>, <code class="md-code md-code-inline">-</code>, <code class="md-code md-code-inline">*</code>, etc. can record feedback about the inputs and outputs that were seen so far. You can check what&#x2019;s inside the feedback vector of a specific closure using the specialized <code class="md-code md-code-inline">%DebugPrint()</code> intrinsic when running with the <code class="md-code md-code-inline">--allow-natives-syntax</code> command line flag (in a Debug build of <code class="md-code md-code-inline">d8</code>).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span><span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">return</span> x + y;
}

<span class="md-code-built_in">console</span>.log(add(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>));
%DebugPrint(add);
</code></pre> <p>Running this with <code class="md-code md-code-inline">--allow-natives-syntax</code> in <code class="md-code md-code-inline">d8</code> we observe:</p> <pre class="md-code-block"><code class="md-code md-lang-xml">$ out/Debug/d8 --allow-natives-syntax add.js
DebugPrint: 0xb5101ea9d89: [Function] in OldSpace
&#x2026;
 - feedback vector: 0xb5101eaa091: [FeedbackVector] in OldSpace
 - length: 1
 SharedFunctionInfo: 0xb5101ea99c9 <span class="md-code-tag">&lt;<span class="md-code-title">SharedFunctionInfo</span> <span class="md-code-attribute">add</span>&gt;</span>
 Optimized Code: 0
 Invocation Count: 1
 Profiler Ticks: 0
 Slot #0 BinaryOp BinaryOp:SignedSmall
&#x2026;
</code></pre> <p>We can see the invocation count is 1, since we ran the function <code class="md-code md-code-inline">add</code> exactly once. Also there&#x2019;s no optimized code yet (indicated by the arguably confusing <code class="md-code md-code-inline">0</code> output). But there&#x2019;s exactly one slot in the Feedback Vector, which is a <code class="md-code md-code-inline">BinaryOp</code> slot whose current feedback is <code class="md-code md-code-inline">SignedSmall</code>. What does that mean? The bytecode <code class="md-code md-code-inline">Add</code> that refers to the feedback slot 0 has only seen inputs of type <code class="md-code md-code-inline">SignedSmall</code> so far and has also only produced outputs of type <code class="md-code md-code-inline">SignedSmall</code> up until now.</p> <p>But what is this <code class="md-code md-code-inline">SignedSmall</code> type about? JavaScript doesn&#x2019;t have a type of that name. The name comes from an optimization that is done in V8 when representing small signed integer values that occur frequently enough in programs to deserve a special treatment (other JavaScript engines have similar optimizations).</p> <h2 id="excurse-value-representation">Excurse: Value Representation</h2> <p>Let&#x2019;s briefly explore how JavaScript values are represented in V8 to better understand the underlying concept. V8 uses a technique called <a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="noopener noreferrer">Pointer Tagging</a> to represent values in general. Most of the values we deal with live in the JavaScript heap, and have to be managed by the garbage collector (GC). But for some values it would be too expensive to always allocate them in memory. Especially for small integer values that are often used as indices to arrays and temporary computation results.</p> <figure><img alt="Tagging Scheme" title="tagging.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/tagging-fc0ad12f99d1473bb558877337917d2c.png"></figure> <p>In V8, we have two possible <em>tagged representations</em>: A <em>Smi</em> (short for <strong><em>Small Integer</em></strong>) and a <em>HeapObject</em>, which points to memory in the managed heap. We make use of the fact that all allocated objects are aligned on word boundaries (64-bit or 32-bit depending on the architecture), which means that the 2 or 3 least significant bits are always zero. We use the least significant bit to distinguish between a <em>HeapObject</em> (bit is 1) and a <em>Smi</em> (bit is 0). For <em>Smi</em> on 64-bit architectures the least significant 32 bits are actually all zero and the signed 32-bit value is stored in the upper half of the word. This is to allow efficient access to the 32-bit value in memory using a single machine instruction instead of having to load and shift the value, but also because 32-bit arithmetic is common for bitwise operations in JavaScript.</p> <p>On 32-bit architectures, the <em>Smi</em> representation has the least significant bit set to 0 and a signed 31-bit value shifted to the left by one stored in the upper 31-bit of the word.</p> <h2 id="feedback-lattice">Feedback Lattice</h2> <p>The <code class="md-code md-code-inline">SignedSmall</code> feedback type refers to all values that have <em>Smi</em> representation. For the <code class="md-code md-code-inline">Add</code> operation it means that it has only seen inputs represented as <em>Smi</em> so far and all outputs that were produced could also be represented as <em>Smi</em> (i.e. the values didn&#x2019;t overflow the range of possible 32-bit integer values). Let&#x2019;s check what happens if we also call add with other numbers that are not representable as <em>Smi</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span><span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">return</span> x + y;
}

<span class="md-code-built_in">console</span>.log(add(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>));
<span class="md-code-built_in">console</span>.log(add(<span class="md-code-number">1.1</span>, <span class="md-code-number">2.2</span>));
%DebugPrint(add);
</code></pre> <p>Running this again with <code class="md-code md-code-inline">--allow-natives-syntax</code> in <code class="md-code md-code-inline">d8</code> we observe:</p> <pre class="md-code-block"><code class="md-code md-lang-xml">$ out/Debug/d8 --allow-natives-syntax add.js
DebugPrint: 0xb5101ea9d89: [Function] in OldSpace
&#x2026;
 - feedback vector: 0x3fd6ea9ef9: [FeedbackVector] in OldSpace
 - length: 1
 SharedFunctionInfo: 0x3fd6ea9989 <span class="md-code-tag">&lt;<span class="md-code-title">SharedFunctionInfo</span> <span class="md-code-attribute">add</span>&gt;</span>
 Optimized Code: 0
 Invocation Count: 2
 Profiler Ticks: 0
 Slot #0 BinaryOp BinaryOp:Number
&#x2026;
</code></pre> <p>First of all, we see that the invocation count is now 2, since we ran the function twice. And then we see that the <code class="md-code md-code-inline">BinaryOp</code> slot value changed to <code class="md-code md-code-inline">Number</code>, which indicates that we&#x2019;ve seen arbitrary numbers for the addition (i.e. non-integer values). For addition there&#x2019;s a lattice of possible states for feedback, which roughly looks like this:</p> <figure><img alt="Feedback Lattice" title="lattice.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/lattice-951ed244c48545b19d7e895e1e143e41.png"></figure> <p>The feedback starts as <code class="md-code md-code-inline">None</code>, which indicates that we haven&#x2019;t seen anything so far, so we don&#x2019;t know anything. The <code class="md-code md-code-inline">Any</code> state indicates that we have seen a combination of incompatible inputs or outputs. The <code class="md-code md-code-inline">Any</code> state thus indicates that the <code class="md-code md-code-inline">Add</code> is considered <em>polymorphic</em>. In contrast, the remaining states indicate that the <code class="md-code md-code-inline">Add</code> is <em>monomorphic</em>, because it has seen and produced only values that are somewhat the same.</p> <ul> <li><code class="md-code md-code-inline">SignedSmall</code> means that all values have been small integers (signed 32-bit or 31-bit depending on the word size of the architecture), and all of them have been represented as <em>Smi</em>.</li> <li><code class="md-code md-code-inline">Number</code> indicates that all values have been regular numbers (this includes <code class="md-code md-code-inline">SignedSmall</code>).</li> <li><code class="md-code md-code-inline">NumberOrOddball</code> includes all the values from <code class="md-code md-code-inline">Number</code> plus <code class="md-code md-code-inline">undefined</code>, <code class="md-code md-code-inline">null</code>, <code class="md-code md-code-inline">true</code> and <code class="md-code md-code-inline">false</code>.</li> <li><code class="md-code md-code-inline">String</code> means that both inputs have been string values.</li> <li><code class="md-code md-code-inline">BigInt</code> means that both inputs have been BigInts, see the current <a href="https://tc39.github.io/proposal-bigint/" target="_blank" rel="noopener noreferrer">stage 2 proposal</a> for details.</li> </ul> <p>It&#x2019;s important to note that the feedback can only progress in this lattice. It&#x2019;s impossible to ever go back. If we&#x2019;d ever go back then we risk entering a so-called <em>deoptimization loop</em> where the optimizing compiler consumes feedback and bails out from optimized code (back to the interpreter) whenever it sees values that don&#x2019;t agree with the feedback. The next time the function gets hot we will eventually optimize it again. So if we didn&#x2019;t progress in the lattice then TurboFan would generate the same code again, which effectively means it will bail out on the same kind of input again. Thus the engine would be busy just optimizing and deoptimizing code, instead of running your JavaScript code at high speed.</p> <h1 id="the-optimization-pipeline">The Optimization Pipeline</h1> <p>Now that we know how Ignition collects feedback for the <code class="md-code md-code-inline">add</code> function, let&#x2019;s see how TurboFan makes use of that feedback to generate minimal code. I&#x2019;ll use the special intrinsic <code class="md-code md-code-inline">%OptimizeFunctionOnNextCall()</code> to trigger optimization of a function in V8 at a very specific point in time. We often use these intrinsics to write tests that stress the engine in a very specific way.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span><span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">return</span> x + y;
}

add(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>); <span class="md-code-comment">// Warm up with SignedSmall feedback.</span>
%OptimizeFunctionOnNextCall(add);
add(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>); <span class="md-code-comment">// Optimize and run generated code.</span>
</code></pre> <p>Here we explicitly warm up the <code class="md-code md-code-inline">x+y</code> site with <code class="md-code md-code-inline">SignedSmall</code> feedback by passing in two integer values whose sum also fits into the small integer range. Then we tell V8 that it should optimize the function <code class="md-code md-code-inline">add</code> (with TurboFan) when it&#x2019;s called the next time, and eventually we call <code class="md-code md-code-inline">add</code>, which triggers TurboFan and then runs the generated machine code.</p> <figure><img alt="TurboFan" title="turbofan.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/turbofan-8e81982d019e4a4dada4d69e751bbb72.png"></figure> <p>TurboFan takes the bytecode that was previously generated for <code class="md-code md-code-inline">add</code> and extracts the relevant feedback from the <code class="md-code md-code-inline">FeedbackVector</code> of <code class="md-code md-code-inline">add</code>. It turns this into a graph representation and passes the graph through the various phases of the frontend, optimization and backend stages. I&#x2019;m not going into the details of the passes here, that&#x2019;s a topic for a separate blog post (or a series of separate blog posts). Instead we&#x2019;re going to look at the generated machine code and see how the speculative optimization works. You can see the code generated by TurboFan by passing the <code class="md-code md-code-inline">--print-opt-code</code> flag to <code class="md-code md-code-inline">d8</code>.</p> <figure><img alt="Generated assembly code" title="overview.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/overview-70ad3de4f5c54fdeaf39f4a26fad43aa.png"></figure> <p>This is the x64 machine code that is generated by TurboFan, with annotations from me and leaving out some technical details that don&#x2019;t matter (i.e. the exact call sequence to the <code class="md-code md-code-inline">Deoptimizer</code>). So let&#x2019;s see what the code does:</p> <pre class="md-code-block"><code class="md-code md-lang-assembly"># Prologue
leaq rcx,[rip+0x0]
movq rcx,[rcx-0x37]
testb [rcx+0xf],0x1
jnz CompileLazyDeoptimizedCode
push rbp
movq rbp,rsp
push rsi
push rdi
cmpq rsp,[r13+0xdb0]
jna StackCheck
</code></pre> <p>The prologue checks whether the code object is still valid or whether some condition changed which requires us to throw away the code object. This was recently introduced by my intern <a href="https://twitter.com/jupvfranco" target="_blank" rel="noopener noreferrer">Juliana Franco</a> as part of her <a href="https://v8.dev/blog/lazy-unlinking" target="_blank" rel="noopener noreferrer">&#x201C;Internship on Laziness&#x201D;</a>. Once we know that the code is still valid, we build the <em>stack frame</em> and check that there&#x2019;s enough space left on the stack to execute the code.</p> <pre class="md-code-block"><code class="md-code md-lang-assembly"># Check x is a small integer
movq rax,[rbp+0x18]
test al,0x1
jnz Deoptimize
# Check y is a small integer
movq rbx,[rbp+0x10]
testb rbx,0x1
jnz Deoptimize
# Convert y from Smi to Word32
movq rdx,rbx
shrq rdx, 32
# Convert x from Smi to Word32
movq rcx,rax
shrq rcx, 32
</code></pre> <p>Then we start with the body of the function. We load the values of the parameters <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code> from the stack (relative to the frame pointer in <code class="md-code md-code-inline">rbp</code>) and check if both values have <em>Smi</em> representation (since feedback for + says that both inputs have always been <em>Smi</em> so far). This is done by testing the least significant bit. Once we know that they are both represented as <em>Smi</em>, we need to convert them to 32-bit representation, which is done by shifting the value by 32 bit to the right.</p> <p>If either <code class="md-code md-code-inline">x</code> or <code class="md-code md-code-inline">y</code> is not a <em>Smi</em> the execution of the optimized code aborts immediately and the <code class="md-code md-code-inline">Deoptimizer</code> restores the state of the function in the interpreter right before the <code class="md-code md-code-inline">Add</code>.</p> <p>Side note: We could also perform the addition on the <em>Smi</em> representation here; that&#x2019;s what our previous optimizing compiler Crankshaft did. This would save us the shifting, but currently TurboFan doesn&#x2019;t have a good heuristic to decide whether it&#x2019;s beneficial to do the operation on <em>Smi</em> instead, which is not always the ideal choice and highly dependent on the context in which this operation is used.</p> <pre class="md-code-block"><code class="md-code md-lang-assembly"># Add x and y (incl. overflow check)
addl rdx,rcx
jo Deoptimize
# Convert result to Smi
shlq rdx, 32
movq rax,rdx
# Epilogue
movq rsp,rbp
pop rbp
ret 0x18
</code></pre> <p>Then we go on to perform the integer addition on the inputs. We need to test explicitly for overflow, since the result of the addition might be outside the range of 32-bit integers, in which case we&#x2019;d need to go back to the interpreter, which will then learn <code class="md-code md-code-inline">Number</code> feedback on the <code class="md-code md-code-inline">Add</code>. Finally we convert the result back to <em>Smi</em> representation by shifting the signed 32-bit value up by 32 bit, and then we return the value in the accumulator register <code class="md-code md-code-inline">rax</code>.</p> <p>As said before, this is not yet the perfect code for this case, since here it would be beneficial to just perform the addition on <em>Smi</em> representation directly, instead of going to <em>Word32</em>, which would save us three shift instructions. But even putting aside this minor aspect, you can see that the generated code is highly optimized and specialized to the profiling feedback. It doesn&#x2019;t even try to deal with other numbers, strings, big ints or arbitrary JavaScript objects here, but focuses only on the kind of values we&#x2019;ve seen so far. This is the <strong>key ingredient</strong> to peak performance for many JavaScript applications.</p> <h2 id="making-progress">Making progress</h2> <p>So what if you suddenly change your mind and want to add numbers instead? Let&#x2019;s change the example to something like this instead:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span><span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">return</span> x + y;
}

add(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>); <span class="md-code-comment">// Warm up with SignedSmall feedback.</span>
%OptimizeFunctionOnNextCall(add);
add(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>); <span class="md-code-comment">// Optimize and run generated code.</span>
add(<span class="md-code-number">1.1</span>, <span class="md-code-number">2.2</span>); <span class="md-code-comment">// Oops?!</span>
</code></pre> <p>Running this with <code class="md-code md-code-inline">--allow-natives-syntax</code> and <code class="md-code md-code-inline">--trace-deopt</code> we observe the following:</p> <figure><img alt="Deoptimization example" title="deopt.png" class="" src="https://s3.amazonaws.com/images.ponyfoo.com/uploads/deopt-7b9afe63da574ea582595abb7681fb7b.png"></figure> <p>That&#x2019;s a lot of confusing output. But let&#x2019;s extract the important bits. First of all, we print a reason why we had to deoptimize, and in this case it&#x2019;s <code class="md-code md-code-inline">not a Smi</code>, which means we baked in the assumption somewhere that a value is a <em>Smi</em>, but now we saw a <em>HeapObject</em> instead. Indeed it&#x2019;s the value in <code class="md-code md-code-inline">rax</code>, which is supposed to be a <em>Smi</em>, but it&#x2019;s the number 1.1 instead. So we fail on the first check for the <code class="md-code md-code-inline">x</code> parameter and we need to deoptimize to go back to interpreting the bytecode. That is a topic for a separate article though.</p> <h1 id="takeaway">Takeaway</h1> <p>I hope you enjoyed this dive into how speculative optimization works in V8 and how it helps us to reach peak performance for JavaScript applications. Don&#x2019;t worry too much about these details though. When writing applications in JavaScript focus on the application design instead and make sure to use appropriate data structures and algorithms. Write idiomatic JavaScript, and let us worry about the low level bits of the JavaScript performance instead. If you find something that is too slow, and it shouldn&#x2019;t be slow, please <a href="http://crbug.com/v8/new" target="_blank" rel="noopener noreferrer">file a bug report</a>, so we get a chance to look into that.</p></div>
